클래스명
소스파일명과 대소문자가 일치해야.
숫자로 시작X.
공백 포함X.
클래스명은 대문자로 시작. ex)SportsCar
변수명은 소문자로 시작.

// 행 주석
/* ~ */ 사이에 있는 모든 범위 주석
주석은 코드 내 어디든 가능.but문자열""내부에는 올수 없음.

변수선언
int a; 
String s; ->대문자.클래스임.

값저장
a = 10; 
String ss = "가나다";
쌍따옴표 문자열
홑따옴표 문자하나

리터럴: 소스 코드 내에서 직접 입력된 값. 
상수와 같은 의미지만 상수는 '변하지 않는 변수'기때문에 이와 구분하기 위해 리터럴이란 용어 사용.
10, "가나다"는 리터럴

Math.random()
클래스임.
0.0부터 1.0사이에 속하는  double타입의 랜덤값 하나를 리턴.
0.0은 포함, 1.0은 포함되지 않음.

(int)(Math.random()*10)
0부터 9까지 중 임의의 수 나옴.

(int)정수값으로 나오게

Scanner클래스임
Scanner scan = new Scanner(System.in);
위에 import java.util.Scanner;
인풋받을때
int input = scan.nextInt();



---------참조타입---------------------
변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.
int[] scores = {1,2,3};
scores는 스택 영역에 생성되지만, {1,2,3}배열은 힙영역에 생성.
배열변수scores에는 힙 영역의 주소가 저장. 자바에서는 배열을 객체로 취급한다.
*null
참조타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null값을 가질 수 있다.
*NullPointerException
참조타입변수가 null을 가지고 있을 경우, 참조타입변수는 사용할 수 없다.

String hobby = null;
String변수가 참조하는 String 객체가 없다는 뜻.
String hobby = "여행";
hobby = null;
객체를 없애고 싶을 때 null로 만듦.
참조를 잃은 객체는 쓰레기 객체->메모리에서 자동 제거.

자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어 있다.

new연산자는 힙영역에 새로운 객체를 만들 때 사용하는 연산자.

동일한 String객체이건 다른String객체이건 상관없이 문자열만 비교할때 .equals()메소드 사용.
==는 객체의 번지 비교이기 때문에 문자열 비교에 사용할 수 없다.

***배열
X배열생성 안되는경우X
타입[] 변수;
변수={1,2,3,4} //컴파일에러

배열변수 미리 선언 후 나중에 값 목록이 결정되는 상황이라면
new연산자 사용.
변수=new 타입[] {1,2,3,4};

메소드의 매개값이 배열일 경우도 마찬가지
int result = add( new int[] {1,2,3} );

O배열생성 되는 경우O
1. 배열과 값 함께 선언
 타입[] 변수 = {1,2,3};
 타입 변수[] = {1,2,3};

2. 배열 먼저 선언 후 값
타입[]변수;
변수=new 타입[] {1,2,3,4};

3. 배열길이 선언후 값
 타입[] 변수 = new 타입[길이]
 변수[인덱스] = 1;

***2차원배열
1.배열길이 선언
타입[][] 변수 = new int[2][3]

2.행길이 먼저 선언 후 열길이 선언
타입[][] 변수 = new 타입[2][];
변수[0] = new 타입[3];
변수[1] = new 타입[4];

3. 값이 있을 경우
타입[][] 변수 = {{값,값}, {값,값}};
----------------------------------------------------------------------

문자열을 정수로 변환
int 변수 = Integer.parseInt("정수로 변환 가능한 문자열");






=====클래스===========================
***클래스 선언
public class 클래스명 {}
파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다.

클래스: 객체를 생성할 설계도

***객체 생성
new 클래스(); 
new는 클래스로부터 객체를 생성시키는 연산자. 힙 영역에 객체를 생성.
new 연산자 뒤에는 생성자가 옴. 생성자는 클래스()형태.

1.
클래스 변수;
변수 = new 클래스();

2. 
클래스 변수 = new 클래스();


클래스는 두가지 용도.
하나는 라이브로리(API)용.
하나는 실행용.
라이브러리인 동시에 실행 클래스로 만들 수도 있음.

***클래스의 구성 멤버
1. 필드
생성자와 메소드 전체에서 사용.
객체가 소멸되지 않는 한 객체와 함께 존재.
클래스중괄호{}어디서든 존재 가능, 
but 생성자와 메소드 중괄호 블록 내부에는 선언될 수 없다.
클래스 외부에서 사용할 경우 우선저그로 클래스로부터 객체를 생성한 뒤 필드 사용.
도트(.)연산자로 필드에 접근할 수 있음.
Car mycar = new Car();
그다음 Car.speed

2.생성자
필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다.
클래스 이름으로 되어 있고 리턴타입이 없다.
생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다.
모든 클래스는 생성자가 반드시 존재.
하나 이상 가질 수 있음.
생성자를 생략하면 기본생성자가 생성.

3.메소드

리턴타입 메소드이름 ([매개변수선언]) {
실행할코드}

리턴타입
리턴값이 없을경우: void
리턴값이 있을경우: 데이터타입

외부클래스에서 Calculator 클래스의 메소드를 호출하기 위해서는
Calculator 객체를 생성하고 참조변수myCalc
Calculator myCalc = new Calculator();
myCalc.메소드이름-> 메소드 블록 실행



static 정적인. 고정된
객체를 생성하지 않고 사용할 수 있는 필드와 메소드.
객체(인스턴스)에 소속된 멤버가 아니라 클래스에 소속된 멤버.
메모리가 할당되어 계속 자리를 차지하고 있음.
반드시 클래스 안에 들어있어야 하지만 클래스와 상관없이 따로 노는.
객체생성 없이 사용가능.

클래스.필드;
클래스.메소드(); 로 접근.
Calculator.pi;
Calculator.plus(10,5);

Calculator myCalcu = new Calculator();
myCalcu.pi로도 접근 가능하지만 경고 표시남.

static 내부에는 인스턴스 필드나 인스턴스 메소드 사용불가
this키워드도 사용 불가.
내부에 인스턴스 멤버 사용하고 싶다면 객체 먼저 생성해야.
그래서 main메소드 안에서 인스턴스 멤버 사용할 때 객체 생성하는 것.
(int x; -> 인스턴스
 static int y; -> 정적)



